<?php

declare(strict_types=1);

namespace App\Services;

use Exception;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

final class VulnerabilityScanService
{
    /**
     * @var array<string, mixed>
     */
    private array $config;

    public function __construct()
    {
        $this->config = config('vulnerability_scan', [
            'enabled' => true,
            'scan_frequency' => 'daily', // daily, weekly, monthly
            'notify_on_critical' => true,
            'notify_on_high' => true,
            'exclude_paths' => ['vendor/', 'node_modules/', '.git/'],
            'max_scan_time' => 300, // 5 minutes
        ]);
    }

    /**
     * Run vulnerability scan.
     *
     * @return array<string, mixed>
     */
    public function runScan(): array
    {
        if (! $this->config['enabled']) {
            return ['status' => 'disabled', 'message' => 'Vulnerability scanning is disabled'];
        }

        $startTime = microtime(true);
        $results = [
            'scan_id' => uniqid('scan_'),
            'started_at' => now()->toISOString(),
            'vulnerabilities' => [],
            'summary' => [
                'total' => 0,
                'critical' => 0,
                'high' => 0,
                'medium' => 0,
                'low' => 0,
            ],
        ];

        try {
            // Scan dependencies
            $results['vulnerabilities']['dependencies'] = $this->scanDependencies();

            // Scan code
            $results['vulnerabilities']['code'] = $this->scanCode();

            // Scan configuration
            $results['vulnerabilities']['config'] = $this->scanConfiguration();

            // Calculate summary
            $results['summary'] = $this->calculateSummary($results['vulnerabilities']);

            $results['completed_at'] = now()->toISOString();
            $results['duration'] = microtime(true) - $startTime;
            $results['status'] = 'completed';

            // Cache results
            Cache::put('vulnerability_scan_results', $results, 3600);

            // Send notifications if needed
            $this->sendNotifications($results);

            Log::info('Vulnerability scan completed', $results);
        } catch (Exception $e) {
            $results['status'] = 'failed';
            $results['error'] = $e->getMessage();
            $results['completed_at'] = now()->toISOString();

            Log::error('Vulnerability scan failed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);
        }

        return $results;
    }

    /**
     * Scan dependencies for vulnerabilities.
     *
     * @return array<string, mixed>
     */
    private function scanDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Scan Composer dependencies
            $composerVulns = $this->scanComposerDependencies();
            $vulnerabilities = array_merge($vulnerabilities, $composerVulns);

            // Scan NPM dependencies
            $npmVulns = $this->scanNpmDependencies();
            $vulnerabilities = array_merge($vulnerabilities, $npmVulns);
        } catch (Exception $e) {
            Log::error('Dependency scan failed', ['error' => $e->getMessage()]);
        }

        return ['dependencies' => $vulnerabilities];
    }

    /**
     * Scan Composer dependencies.
     *
     * @return list<array<string, mixed>>
     */
    private function scanComposerDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Run composer audit
            $output = shell_exec('composer audit --format=json 2>&1');
            $auditResults = json_decode($output ?: '', true);

            if (isset($auditResults['advisories'])) {
                foreach ($auditResults['advisories'] as $package => $advisories) {
                    foreach ($advisories as $advisory) {
                        $vulnerabilities[] = [
                            'type' => 'dependency',
                            'package' => $package,
                            'severity' => $advisory['severity'] ?? 'unknown',
                            'title' => $advisory['title'] ?? 'Unknown vulnerability',
                            'description' => $advisory['description'] ?? '',
                            'cve' => $advisory['cve'] ?? null,
                            'source' => 'composer',
                        ];
                    }
                }
            }
        } catch (Exception $e) {
            Log::error('Composer audit failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Scan NPM dependencies.
     *
     * @return list<array<string, mixed>>
     */
    private function scanNpmDependencies(): array
    {
        $vulnerabilities = [];

        try {
            // Run npm audit
            $output = shell_exec('npm audit --json 2>&1');
            $auditResults = json_decode($output ?: '', true);

            if (isset($auditResults['vulnerabilities'])) {
                foreach ($auditResults['vulnerabilities'] as $package => $vuln) {
                    $vulnerabilities[] = [
                        'type' => 'dependency',
                        'package' => $package,
                        'severity' => $vuln['severity'] ?? 'unknown',
                        'title' => $vuln['title'] ?? 'Unknown vulnerability',
                        'description' => $vuln['description'] ?? '',
                        'cve' => $vuln['cve'] ?? null,
                        'source' => 'npm',
                    ];
                }
            }
        } catch (Exception $e) {
            Log::error('NPM audit failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Scan code for vulnerabilities.
     *
     * @return array<string, mixed>
     */
    private function scanCode(): array
    {
        $vulnerabilities = [];

        try {
            // Scan for common vulnerabilities
            $vulnerabilities = array_merge($vulnerabilities, $this->scanSqlInjection());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanXss());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanFileUpload());
            $vulnerabilities = array_merge($vulnerabilities, $this->scanAuthentication());
        } catch (Exception $e) {
            Log::error('Code scan failed', ['error' => $e->getMessage()]);
        }

        return ['code' => $vulnerabilities];
    }

    /**
     * Scan for SQL injection vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanSqlInjection(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'DB::raw' => 'Use of DB::raw without proper sanitization',
            'whereRaw' => 'Use of whereRaw without proper sanitization',
            'selectRaw' => 'Use of selectRaw without proper sanitization',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'high',
                    'title' => 'Potential SQL Injection',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for XSS vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanXss(): array
    {
        $vulnerabilities = [];
        $patterns = [
            '{!!' => 'Unescaped output - potential XSS',
            'echo' => 'Direct echo without escaping',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'medium',
                    'title' => 'Potential XSS',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for file upload vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanFileUpload(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'move_uploaded_file' => 'File upload without validation',
            'getClientOriginalName' => 'Using original filename without sanitization',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'high',
                    'title' => 'File Upload Vulnerability',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan for authentication vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanAuthentication(): array
    {
        $vulnerabilities = [];
        $patterns = [
            'password' => 'Hardcoded password',
            'secret' => 'Hardcoded secret',
            'api_key' => 'Hardcoded API key',
        ];

        foreach ($patterns as $pattern => $description) {
            $files = $this->searchInFiles($pattern);
            foreach ($files as $file) {
                $vulnerabilities[] = [
                    'type' => 'code',
                    'severity' => 'critical',
                    'title' => 'Hardcoded Credentials',
                    'description' => $description,
                    'file' => $file,
                    'pattern' => $pattern,
                ];
            }
        }

        return $vulnerabilities;
    }

    /**
     * Scan configuration for vulnerabilities.
     *
     * @return list<array<string, string>>
     */
    private function scanConfiguration(): array
    {
        $vulnerabilities = [];

        try {
            // Check for debug mode in production
            if (config('app.debug') && config('app.env') === 'production') {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'high',
                    'title' => 'Debug Mode in Production',
                    'description' => 'Debug mode is enabled in production environment',
                    'file' => 'config/app.php',
                ];
            }

            // Check for weak encryption key
            $key = config('app.key');
            if (strlen($key) < 32) {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'critical',
                    'title' => 'Weak Encryption Key',
                    'description' => 'Application key is too short',
                    'file' => 'config/app.php',
                ];
            }

            // Check for insecure session configuration
            if (config('session.secure') !== true && config('app.env') === 'production') {
                $vulnerabilities[] = [
                    'type' => 'config',
                    'severity' => 'medium',
                    'title' => 'Insecure Session Configuration',
                    'description' => 'Session cookies are not secure',
                    'file' => 'config/session.php',
                ];
            }
        } catch (Exception $e) {
            Log::error('Configuration scan failed', ['error' => $e->getMessage()]);
        }

        return $vulnerabilities;
    }

    /**
     * Search for patterns in files.
     *
     * @return array<string>
     */
    private function searchInFiles(string $pattern): array
    {
        $files = [];
        $excludePaths = $this->config['exclude_paths'];

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator(base_path(), \RecursiveDirectoryIterator::SKIP_DOTS)
        );

        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $relativePath = str_replace(base_path().'/', '', $file->getPathname());

                // Skip excluded paths
                $shouldExclude = false;
                foreach ($excludePaths as $excludePath) {
                    if (strpos($relativePath, $excludePath) === 0) {
                        $shouldExclude = true;
                        break;
                    }
                }

                if (! $shouldExclude) {
                    $content = file_get_contents($file->getPathname());
                    if ($content !== false && strpos($content, $pattern) !== false) {
                        $files[] = $relativePath;
                    }
                }
            }
        }

        return $files;
    }

    /**
     * Calculate vulnerability summary.
     *
     * @param  array<string, mixed>  $vulnerabilities
     * @return array<string, int>
     */
    private function calculateSummary(array $vulnerabilities): array
    {
        $summary = [
            'total' => 0,
            'critical' => 0,
            'high' => 0,
            'medium' => 0,
            'low' => 0,
        ];

        foreach ($vulnerabilities as $vulns) {
            foreach ($vulns as $vuln) {
                $summary['total']++;
                $severity = strtolower($vuln['severity']);

                if (isset($summary[$severity])) {
                    $summary[$severity]++;
                }
            }
        }

        return $summary;
    }

    /**
     * Send notifications for vulnerabilities.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendNotifications(array $results): void
    {
        $summary = $results['summary'];

        if ($summary['critical'] > 0 && $this->config['notify_on_critical']) {
            $this->sendCriticalNotification($results);
        }

        if ($summary['high'] > 0 && $this->config['notify_on_high']) {
            $this->sendHighNotification($results);
        }
    }

    /**
     * Send critical vulnerability notification.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendCriticalNotification(array $results): void
    {
        try {
            $adminEmails = config('app.admin_emails', []);

            if (! empty($adminEmails)) {
                \Mail::raw(
                    "Critical vulnerabilities found in COPRRA application:\n\n".
                    "Total vulnerabilities: {$results['summary']['total']}\n".
                    "Critical: {$results['summary']['critical']}\n".
                    "High: {$results['summary']['high']}\n".
                    "Medium: {$results['summary']['medium']}\n".
                    "Low: {$results['summary']['low']}\n\n".
                    "Scan ID: {$results['scan_id']}\n".
                    "Time: {$results['completed_at']}",
                    function ($message) use ($adminEmails) {
                        $message->to($adminEmails)
                            ->subject('Critical Vulnerabilities Alert - COPRRA');
                    }
                );
            }
        } catch (Exception $e) {
            Log::error('Failed to send critical vulnerability notification', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Send high vulnerability notification.
     *
     * @param  array<string, mixed>  $results
     */
    private function sendHighNotification(array $results): void
    {
        try {
            $adminEmails = config('app.admin_emails', []);

            if (! empty($adminEmails)) {
                \Mail::raw(
                    "High severity vulnerabilities found in COPRRA application:\n\n".
                    "Total vulnerabilities: {$results['summary']['total']}\n".
                    "Critical: {$results['summary']['critical']}\n".
                    "High: {$results['summary']['high']}\n".
                    "Medium: {$results['summary']['medium']}\n".
                    "Low: {$results['summary']['low']}\n\n".
                    "Scan ID: {$results['scan_id']}\n".
                    "Time: {$results['completed_at']}",
                    function ($message) use ($adminEmails) {
                        $message->to($adminEmails)
                            ->subject('High Severity Vulnerabilities Alert - COPRRA');
                    }
                );
            }
        } catch (Exception $e) {
            Log::error('Failed to send high vulnerability notification', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * Get last scan results.
     *
     * @return array<string, mixed>|null
     */
    public function getLastScanResults(): ?array
    {
        return Cache::get('vulnerability_scan_results');
    }

    /**
     * Get scan statistics.
     *
     * @return array<string, mixed>
     */
    public function getScanStatistics(): array
    {
        $lastScan = $this->getLastScanResults();

        if (! $lastScan) {
            return [
                'last_scan' => null,
                'total_scans' => 0,
                'average_vulnerabilities' => 0,
            ];
        }

        return [
            'last_scan' => $lastScan['completed_at'],
            'total_scans' => 1, // This would be tracked in a database
            'average_vulnerabilities' => $lastScan['summary']['total'],
            'summary' => $lastScan['summary'],
        ];
    }
}
